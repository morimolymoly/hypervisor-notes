# xenでのpage faultのre-injection手法
Xenでのページフォールトの再挿入方法をコールドリーディングにより紐解く．

## エントリポイント
まずは`xen/xen/include/asm-x86/hvm/hvm.h`の中にある`hvm_inject_page_fault`関数に注目する．  
```C
static inline void hvm_inject_page_fault(int errcode, unsigned long cr2)
{
    struct x86_event event = {
        .vector = TRAP_page_fault,
        .type = X86_EVENTTYPE_HW_EXCEPTION,
        .error_code = errcode,
        .cr2 = cr2,
    };

    hvm_inject_event(&event);
}
```
これがどうやらページフォールトを再挿入している関数であることがわかる．  
この関数の中で，`x86_event`構造体を組み立て，`hvm_inject_event`関数に渡している． 
ちなみに`errcode`はPFEC(Page Fault Error Code)で，`cr2`はページフォールトが起こったアドレスが格納されるcr2レジスタの中身である．

## `x86_event`構造体とはなにか？
`xen/arch/x86/x86_emulate/x86_emulate.h`の中で定義されている構造体だ．  
定義は以下のようになっている．  
```C
struct x86_event {
    int16_t       vector;
    uint8_t       type;         /* X86_EVENTTYPE_* */
    uint8_t       insn_len;     /* Instruction length */
    int32_t       error_code;   /* X86_EVENT_NO_EC if n/a */
    unsigned long cr2;          /* Only for TRAP_page_fault h/w exception */
};
```
その名の通り，イベントを表す構造体である．  
`cr2`にはページフォールトが起こったアドレスが格納される．  
普通の例外や割り込みでは使われないはずだ．

## `hvm_inject_event`関数
以下のコードが該当する関数である．  
なお，Assertなコードは本質ではないため除外している．  
```C
void hvm_inject_event(const struct x86_event *event)
{
    struct vcpu *curr = current;
    const uint8_t vector = event->vector;
    //
    // nested vmなコードのところなので省略……
    //
    hvm_funcs.inject_event(event);
}
```
`hvm_funcs`は`struct hvm_function_table hvm_funcs __read_mostly;`である．  
つまり`hvm_function_table`を探す．
これは`xen/include/asm-x86/hvm/hvm.h`で定義されている，`x86/x86_64 CPU virtualization assist specifics`なインターフェースである．  
これはIntel VT-xとAMD SVMを隠蔽している．  
今回はIntel Vt-xに注目していく．

## Intel vt-xでの`hvm_function_table`
`xen/arch/x86/hvm/vmx/vmx.c`の中に定義されている．
```C
static struct hvm_function_table __initdata vmx_function_table = {
    .name                 = "VMX",
    //
    // 省略
    //
    .inject_event         = vmx_inject_event,
    //
    // 省略
    //
};
```
このようにただの関数のテーブルであるが，目的の`inject_event`の実態は`vmx_inject_event`であることがわかる．

## inject_event関数
TBD
```C
/*
 * Generate a virtual event in the guest.
 * NOTES:
 *  - INT 3 (CC) and INTO (CE) are X86_EVENTTYPE_SW_EXCEPTION;
 *  - INT nn (CD nn) is X86_EVENTTYPE_SW_INTERRUPT;
 *  - #DB is X86_EVENTTYPE_HW_EXCEPTION, except when generated by
 *    opcode 0xf1 (which is X86_EVENTTYPE_PRI_SW_EXCEPTION)
 */
static void vmx_inject_event(const struct x86_event *event)
{
    unsigned long intr_info;
    struct vcpu *curr = current;
    struct x86_event _event = *event;

    switch ( _event.vector | -(_event.type == X86_EVENTTYPE_SW_INTERRUPT) )
    {
    case TRAP_debug:
        if ( guest_cpu_user_regs()->eflags & X86_EFLAGS_TF )
        {
            __restore_debug_registers(curr);
            write_debugreg(6, read_debugreg(6) | DR_STEP);
        }
        if ( !nestedhvm_vcpu_in_guestmode(curr) ||
             !nvmx_intercepts_exception(curr, TRAP_debug, _event.error_code) )
        {
            unsigned long val;

            __vmread(GUEST_DR7, &val);
            __vmwrite(GUEST_DR7, val & ~DR_GENERAL_DETECT);
            __vmread(GUEST_IA32_DEBUGCTL, &val);
            __vmwrite(GUEST_IA32_DEBUGCTL, val & ~IA32_DEBUGCTLMSR_LBR);
        }
        if ( cpu_has_monitor_trap_flag )
            break;
        /* fall through */
    case TRAP_int3:
        if ( curr->domain->debugger_attached )
        {
            /* Debug/Int3: Trap to debugger. */
            domain_pause_for_debugger();
            return;
        }
        break;

    case TRAP_page_fault:
        ASSERT(_event.type == X86_EVENTTYPE_HW_EXCEPTION);
        curr->arch.hvm_vcpu.guest_cr[2] = _event.cr2;
        break;
    }

    if ( nestedhvm_vcpu_in_guestmode(curr) )
        intr_info = vcpu_2_nvmx(curr).intr.intr_info;
    else
        __vmread(VM_ENTRY_INTR_INFO, &intr_info);

    if ( unlikely(intr_info & INTR_INFO_VALID_MASK) &&
         (MASK_EXTR(intr_info, INTR_INFO_INTR_TYPE_MASK) ==
          X86_EVENTTYPE_HW_EXCEPTION) )
    {
        _event.vector = hvm_combine_hw_exceptions(
            (uint8_t)intr_info, _event.vector);
        if ( _event.vector == TRAP_double_fault )
            _event.error_code = 0;
    }

    if ( _event.type >= X86_EVENTTYPE_SW_INTERRUPT )
        __vmwrite(VM_ENTRY_INSTRUCTION_LEN, _event.insn_len);

    if ( nestedhvm_vcpu_in_guestmode(curr) &&
         nvmx_intercepts_exception(curr, _event.vector, _event.error_code) )
    {
        nvmx_enqueue_n2_exceptions (curr, 
            INTR_INFO_VALID_MASK |
            MASK_INSR(_event.type, INTR_INFO_INTR_TYPE_MASK) |
            MASK_INSR(_event.vector, INTR_INFO_VECTOR_MASK),
            _event.error_code, hvm_intsrc_none);
        return;
    }
    else
        __vmx_inject_exception(_event.vector, _event.type, _event.error_code);

    if ( (_event.vector == TRAP_page_fault) &&
         (_event.type == X86_EVENTTYPE_HW_EXCEPTION) )
        HVMTRACE_LONG_2D(PF_INJECT, _event.error_code,
                         TRC_PAR_LONG(curr->arch.hvm_vcpu.guest_cr[2]));
    else
        HVMTRACE_2D(INJ_EXC, _event.vector, _event.error_code);
}
```
