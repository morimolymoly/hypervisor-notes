# xenでのpage faultのre-injection手法
Xenでのページフォールトの再挿入方法をコールドリーディングにより紐解く．

## エントリポイント
まずは`xen/xen/include/asm-x86/hvm/hvm.h`の中にある`hvm_inject_page_fault`関数に注目する．  
```C
static inline void hvm_inject_page_fault(int errcode, unsigned long cr2)
{
    struct x86_event event = {
        .vector = TRAP_page_fault,
        .type = X86_EVENTTYPE_HW_EXCEPTION,
        .error_code = errcode,
        .cr2 = cr2,
    };

    hvm_inject_event(&event);
}
```
これがどうやらページフォールトを再挿入している関数であることがわかる．  
この関数の中で，`x86_event`構造体を組み立て，`hvm_inject_event`関数に渡している． 
ちなみに`errcode`はPFEC(Page Fault Error Code)で，`cr2`はページフォールトが起こったアドレスが格納されるcr2レジスタの中身である．

## `x86_event`構造体とはなにか？
`xen/arch/x86/x86_emulate/x86_emulate.h`の中で定義されている構造体だ．  
定義は以下のようになっている．  
```C
struct x86_event {
    int16_t       vector;
    uint8_t       type;         /* X86_EVENTTYPE_* */
    uint8_t       insn_len;     /* Instruction length */
    int32_t       error_code;   /* X86_EVENT_NO_EC if n/a */
    unsigned long cr2;          /* Only for TRAP_page_fault h/w exception */
};
```
その名の通り，イベントを表す構造体である．  
`cr2`にはページフォールトが起こったアドレスが格納される．  
普通の例外や割り込みでは使われないはずだ．

## `hvm_inject_event`関数
以下のコードが該当する関数である．  
なお，Assertなコードは本質ではないため除外している．  
```C
void hvm_inject_event(const struct x86_event *event)
{
    struct vcpu *curr = current;
    const uint8_t vector = event->vector;
    //
    // nested vmなコードのところなので省略……
    //
    hvm_funcs.inject_event(event);
}
```
`hvm_funcs`は`struct hvm_function_table hvm_funcs __read_mostly;`である．  
つまり`hvm_function_table`を探す．
これは`xen/include/asm-x86/hvm/hvm.h`で定義されている，`x86/x86_64 CPU virtualization assist specifics`なインターフェースである．  
これはIntel VT-xとAMD SVMを隠蔽している．  
今回はIntel Vt-xに注目していく．

## Intel vt-xでの`hvm_function_table`
`xen/arch/x86/hvm/vmx/vmx.c`の中に定義されている．
```C
static struct hvm_function_table __initdata vmx_function_table = {
    .name                 = "VMX",
    //
    // 省略
    //
    .inject_event         = vmx_inject_event,
    //
    // 省略
    //
};
```
このようにただの関数のテーブルであるが，目的の`inject_event`の実態は`vmx_inject_event`であることがわかる．

## inject_event関数
```C
/*
 * Generate a virtual event in the guest.
 * NOTES:
 *  - INT 3 (CC) and INTO (CE) are X86_EVENTTYPE_SW_EXCEPTION;
 *  - INT nn (CD nn) is X86_EVENTTYPE_SW_INTERRUPT;
 *  - #DB is X86_EVENTTYPE_HW_EXCEPTION, except when generated by
 *    opcode 0xf1 (which is X86_EVENTTYPE_PRI_SW_EXCEPTION)
 */
static void vmx_inject_event(const struct x86_event *event)
{
    unsigned long intr_info;
    struct vcpu *curr = current;
    struct x86_event _event = *event;

    switch ( _event.vector | -(_event.type == X86_EVENTTYPE_SW_INTERRUPT) )
    {
    case TRAP_debug:
        if ( guest_cpu_user_regs()->eflags & X86_EFLAGS_TF )
        {
            __restore_debug_registers(curr);
            write_debugreg(6, read_debugreg(6) | DR_STEP);
        }
        if ( !nestedhvm_vcpu_in_guestmode(curr) ||
             !nvmx_intercepts_exception(curr, TRAP_debug, _event.error_code) )
        {
            unsigned long val;

            __vmread(GUEST_DR7, &val);
            __vmwrite(GUEST_DR7, val & ~DR_GENERAL_DETECT);
            __vmread(GUEST_IA32_DEBUGCTL, &val);
            __vmwrite(GUEST_IA32_DEBUGCTL, val & ~IA32_DEBUGCTLMSR_LBR);
        }
        if ( cpu_has_monitor_trap_flag )
            break;
        /* fall through */
    case TRAP_int3:
        if ( curr->domain->debugger_attached )
        {
            /* Debug/Int3: Trap to debugger. */
            domain_pause_for_debugger();
            return;
        }
        break;

    case TRAP_page_fault:
        ASSERT(_event.type == X86_EVENTTYPE_HW_EXCEPTION);
        curr->arch.hvm_vcpu.guest_cr[2] = _event.cr2;
        break;
    }
    /*
    if ( nestedhvm_vcpu_in_guestmode(curr) )
        intr_info = vcpu_2_nvmx(curr).intr.intr_info;
    else*/
        __vmread(VM_ENTRY_INTR_INFO, &intr_info);

    if ( unlikely(intr_info & INTR_INFO_VALID_MASK) &&
         (MASK_EXTR(intr_info, INTR_INFO_INTR_TYPE_MASK) ==
          X86_EVENTTYPE_HW_EXCEPTION) )
    {
        _event.vector = hvm_combine_hw_exceptions(
            (uint8_t)intr_info, _event.vector);
        if ( _event.vector == TRAP_double_fault )
            _event.error_code = 0;
    }
    /*
    if ( _event.type >= X86_EVENTTYPE_SW_INTERRUPT )
        __vmwrite(VM_ENTRY_INSTRUCTION_LEN, _event.insn_len);
    
    if ( nestedhvm_vcpu_in_guestmode(curr) &&
         nvmx_intercepts_exception(curr, _event.vector, _event.error_code) )
    {
        nvmx_enqueue_n2_exceptions (curr, 
            INTR_INFO_VALID_MASK |
            MASK_INSR(_event.type, INTR_INFO_INTR_TYPE_MASK) |
            MASK_INSR(_event.vector, INTR_INFO_VECTOR_MASK),
            _event.error_code, hvm_intsrc_none);
        return;
    }
    else*/
        __vmx_inject_exception(_event.vector, _event.type, _event.error_code);

    if ( (_event.vector == TRAP_page_fault) &&
         (_event.type == X86_EVENTTYPE_HW_EXCEPTION) )
        HVMTRACE_LONG_2D(PF_INJECT, _event.error_code,
                         TRC_PAR_LONG(curr->arch.hvm_vcpu.guest_cr[2]));
/*
    else
        HVMTRACE_2D(INJ_EXC, _event.vector, _event.error_code);*/
}
```
最初のswitch-caseで`TRAP_page_fault`に行き，
```C
curr->arch.hvm_vcpu.guest_cr[2] = _event.cr2;
```
で，VCPUのCR2にトラップ時のcr2の値が格納される．  
次に，Bareflankでの`vm_entry_interruption_information`を読み出す．(`vmread`命令を直接叩いているが，xenにはvmcs情報が保存されていないのか……)
これはintelの仕様書を読むよりもbareflankのコードを読むほうが構造化されており把握しやすいので参照してください．  
`intr_info`に割り込みの情報が保存される．  
次に，`valid_bit`が`false`で，ハードウェアエクセプションタイプならば，下記のコードが実行される．  
`valid_bit`の指すところがいまいち把握できていないが，bareflankで起こったページフォールトを確認すると，`valid_bit`は`false`だった．  
したがって，下記のコードが実行される．
```C
_event.vector = hvm_combine_hw_exceptions(
    (uint8_t)intr_info, _event.vector);
if ( _event.vector == TRAP_double_fault )
    _event.error_code = 0;
```
`hvm_combine_hw_exceptions`関数は
```C
/*
 * Combine two hardware exceptions: @vec2 was raised during delivery of @vec1.
 * This means we can assume that @vec2 is contributory or a page fault.
 */
uint8_t hvm_combine_hw_exceptions(uint8_t vec1, uint8_t vec2)
{
    const unsigned int contributory_exceptions =
        (1 << TRAP_divide_error) |
        (1 << TRAP_invalid_tss) |
        (1 << TRAP_no_segment) |
        (1 << TRAP_stack_error) |
        (1 << TRAP_gp_fault);
    const unsigned int page_faults =
        (1 << TRAP_page_fault) |
        (1 << TRAP_virtualisation);

    /* Exception during double-fault delivery always causes a triple fault. */
    if ( vec1 == TRAP_double_fault )
    {
        hvm_triple_fault();
        return TRAP_double_fault; /* dummy return */
    }

    /* Exception during page-fault delivery always causes a double fault. */
    if ( (1u << vec1) & page_faults )
        return TRAP_double_fault;

    /* Discard the first exception if it's benign or if we now have a #PF. */
    if ( !((1u << vec1) & contributory_exceptions) ||
         ((1u << vec2) & page_faults) )
        return vec2;

    /* Cannot combine the exceptions: double fault. */
    return TRAP_double_fault;
}
```
TBD  

次に，ソフトウェアエクセプション，ICEBP，INT3 (CC), INTO (CE)ならばBareflankでいうところの`vm_entry_instruction_length`に命令の長さが格納される．  
ページフォールトは違うので格納されない．  

次に，`__vmx_inject_exception`が実行される．  
TBD  

最後に，`HVMTRACE_LONG_2D`が実行される．
これは`__trace_var`を内部で呼び出していて，trace bufferに書き込むための関数である．デバッグ用？？
